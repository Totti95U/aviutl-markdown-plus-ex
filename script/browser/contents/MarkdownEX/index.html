<!DOCTYPE html>
<html lang="ja">
<style>
html, body {
  margin: 0;
  padding: 0;
}
body {
  margin-top: 1px;
  overflow: hidden;
}
</style>
<link rel="stylesheet" id="markdown-style" href="./css/markdown/github-markdown.css">
<link rel="stylesheet" id="hljs-style" href="./css/hljs/github.css">
<div class="markdown-body"></div>
<script src="./marked.min.js"></script>
<script src="./highlight.min.js"></script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
  },
};
</script>
<script id="MathJax-script" src="./mathjax/tex-chtml-full.js"></script>
<script type="module">
const markdownStyle = document.getElementById('markdown-style');
const hljsStyle = document.getElementById('hljs-style');
const elem = document.querySelector('div.markdown-body');

const current = {
  file: 'a',
  markdown: '',
  emojis_name: '',
  emojis: {},
};

const loadEmojis = name => {
  return fetch(`./img/${name}/setting.json`)
    .then(r => r.text())
    .then(t => JSON.parse(t));
};

const renderer = new marked.Renderer();
renderer.text = text => {
  let output = '';
  let start = 0;
  for (const match of text.matchAll(/:([a-zA-Z0-9-+_]+):/g)) {
    output += text.substring(start, match.index);
    start = match.index + match[0].length;
    if (match[1] in current.emojis) {
      output += `<img class="emoji" src="./img/${current.emojis_name}/${current.emojis[match[1]]}">`;
    } else {
      output += match[0];
    }
  }
  output += text.substring(start);
  return output;
};

marked.setOptions({
  langPrefix: '',
  highlight: (code, lang) => {
    const language = hljs.getLanguage(lang) ? lang : 'plaintext';
    return hljs.highlight(code, {language}).value;
  },
  renderer: renderer,
});

const linkPrefix = `${location.protocol}//${location.host}`
const parseParam = param => {
  let prev = 0;
  const popstring = () => {
    const next = param.indexOf('/', prev);
    if (next === -1) throw new Error('invalid parameter');
    const s = param.substring(prev, next);
    prev = next + 1;
    return s;
  }

  const parsed = {};
  parsed.mode = popstring();
  parsed.scale = parseInt(popstring(), 10) / 100;
  parsed.markdownStyle = `${linkPrefix}/css/markdown/${popstring()}.css`;
  parsed.hljsStyle = `${linkPrefix}/css/hljs/${popstring()}.css`;
  parsed.emojis = popstring();
  parsed.markdown = param.substring(prev);
  return parsed;
};

AviUtlBrowser.registerRenderer(async params => {
  const param = parseParam(params.param);
  let update = false;

  elem.style.zoom = param.scale;
  if (markdownStyle.href !== param.markdownStyle) {
    markdownStyle.href = param.markdownStyle;
  }
  if (hljsStyle.href !== param.hljsStyle) {
    hljsStyle.href = param.hljsStyle;
  }

  if (current.emojis_name !== param.emojis) {
    current.emojis_name = param.emojis;
    current.emojis = await loadEmojis(param.emojis);
    update = true;
  }

  if (param.mode === "text" && current.markdown !== param.markdown) {
    current.markdown = param.markdown;
    update = true;
  } else if (param.mode === "file" && current.file !== params.userfile) {
    current.file = params.userfile;
    current.markdown = await fetch('/userfile').then(r => r.text());
    update = true;
  }

  if (update) {
    elem.innerHTML = marked(current.markdown);
    MathJax.typeset();
  }

  return '';
});
</script>
</html>
